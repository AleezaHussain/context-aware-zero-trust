// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// NOTE: This contract optionally integrates with a Groth16 Verifier generated by snarkjs.
// If you don't have Verifier.sol available, this file provides a minimal Verifier
// interface so the rest of the harness can compile. Replace with the generated
// Verifier.sol when doing hybrid-zk runs.

pragma solidity ^0.8.20;

interface Verifier {
    function verifyProof(uint[2] calldata a, uint[2][2] calldata b, uint[2] calldata c, uint[] calldata input) external view returns (bool);
}

contract HybridContextZK {

    Verifier public verifier;

    mapping(address => bool) public authorizedGateway;
    mapping(address => bool) public authorizedDevice;
    mapping(address => bytes32) public lastCommitPoseidon;

    mapping(address => bytes) public encMetrics; // HE bundle
    mapping(address => bytes) public encAttrs;   // IPE bytes

    event ContextUpdated(address indexed device, uint256 CtPoseidon);
    event ContextViolation(address indexed device, uint256 prev, uint256 curr);

    constructor(address _verifier) { verifier = Verifier(_verifier); }

    // host-provided auth (caller must be an authorized gateway)
    modifier onlyGateway() {
        require(authorizedGateway[msg.sender], "not gateway");
        _;
    }

    function grantGateway(address g, bool ok) external {
        // intentionally minimal: owner pattern omitted for brevity â€” adapt as needed
        authorizedGateway[g] = ok;
    }

    function grantDevice(address d, bool ok) external {
        authorizedDevice[d] = ok;
    }

    function _updateCommit(address device, uint256 CtPoseidon) internal {
        uint256 prev = uint256(lastCommitPoseidon[device]);
        if (prev != 0 && prev != CtPoseidon) {
            emit ContextViolation(device, prev, CtPoseidon);
        }
        lastCommitPoseidon[device] = bytes32(CtPoseidon);
        emit ContextUpdated(device, CtPoseidon);
    }

    // setContextHybridZK: verifier is the Groth16 verifier generated by snarkjs
    // a,b,c are the Groth16 proof parts; publicSignals should include CtPoseidon and windowTag (order from circuit)
    function setContextHybridZK(
        address device,
        uint256 nonce,
        uint256 CtPoseidon,
        bytes calldata ctMetricsBlob,
        bytes calldata ctAttrBytes,
        uint256[2] calldata a,
        uint256[2][2] calldata b,
        uint256[2] calldata c,
        uint256[] calldata publicSignals
    ) external onlyGateway {
        // Basic checks
        require(publicSignals.length >= 1 && publicSignals[0] == CtPoseidon, "Ct mismatch");

        // Verify proof
        require(verifier.verifyProof(a, b, c, publicSignals), "bad proof");

        // Store opaque ciphertexts
        encMetrics[device] = ctMetricsBlob;
        encAttrs[device] = ctAttrBytes;

        _updateCommit(device, CtPoseidon);
    }
}
